<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D3 Map</title>
    <script src="https://d3js.org/d3.v4.min.js"></script>
</head>
<body>

<style>
body{
    font-family: sans-serif;
}

.label {
    font-family: "Arial", sans-serif;
    font-size: 9px;
    background-color: rgba(255, 255, 255, 0.7);
    padding: 1px 2px;
    border-radius: 2px;
    border: 1px solid #bbb;
    pointer-events: none; /* makes sure labels don't interfere with map interactions */
}

#tooltip {
    position: absolute;
    background-color: #fff;
    padding: 10px;
    opacity: 0.9;
    pointer-events: none;
}

.hidden {
    visibility: hidden;
}

.show{
    visibility: visible;
}

.centroid-line{
    stroke: #bbbbbb;
    stroke-width: 1px;
    pointer-events: none;
}

path:hover {
    stroke: #ffffff;  /* Change to your desired glow color */
    stroke-width: 2;  /* Adjust as needed */
    filter: url(#glow);
}
</style>

<div id="labelContainer" style="position: absolute; top: 0; left: 0;">
<svg width="960" height="800"></svg>
</div>

<div id="tooltip" class="hidden">
    <div id="tip_name"></div>
    <div id="tip_details"></div>
</div>

<script>
    // Your D3.js code goes here
    var svg = d3.select("svg");
    var width = +svg.attr("width");
    var height = +svg.attr("height");
    var labelContainer = d3.select("#labelContainer");

    var centerX = width / 2;
    var centerY = height / 2;

    d3.json("/census_tracts", function(error, data) {
        if (error) throw error;
        var projection = d3.geoMercator()
                            .fitSize([width-200, height-200], data)
        var translate = projection.translate();
        projection.translate([translate[0] + 100, translate[1] + 100]);

        var color = d3.scaleSequential(d3.interpolateMagma)
                      .domain([-5, d3.max(data.features, d => Math.sqrt(d.properties.density))]);
        var path = d3.geoPath().projection(projection);
        var centroids = data.features.map(function(d) {
            return path.centroid(d);
        });
        var defs = svg.append("defs");

        var filter = defs.append("filter")
            .attr("id", "glow");

        filter.append("feGaussianBlur")
            .attr("stdDeviation", "3.5")
            .attr("result", "coloredBlur");

        var feMerge = filter.append("feMerge");
        feMerge.append("feMergeNode").attr("in", "coloredBlur");
        feMerge.append("feMergeNode").attr("in", "SourceGraphic");

        svg.selectAll("path")
            .data(data.features)
            .enter().append("path")
            .attr("d", path)
            .attr("stroke", "#cccccc")
            .attr("fill", function(d){
                return color(Math.sqrt(d.properties.density)); 
            })
            .on("mouseover", function(d) {
                this.parentNode.appendChild(this);
                svg.selectAll(`.lbl_${d.properties.geo_id}`).classed('hidden', false);
                svg.selectAll(`.lbl_${d.properties.geo_id}`).nodes().forEach(function(d){
                    d.parentNode.appendChild(d);
                });
                labelContainer.selectAll(`.lbl_${d.properties.geo_id}`).classed('hidden', false);
                // svg.selectAll(`.lbl_${d.properties.geo_id}`).classed('show', true);
                // console.log(color(d.properties.density));
                // d3.select("#name").text(d.properties.name);
                // d3.select("#details").text(d.properties.geo_id);
                // d3.select("#area").text(d.properties.density + " p/sq");
                // d3.select("#tooltip")
                //     .style("left", (d3.event.pageX + 5) + "px")
                //     .style("top", (d3.event.pageY - 28) + "px")
                //     .classed("hidden", false);
            })
            .on("mouseout", function(d) {
                svg.selectAll(`.lbl_${d.properties.geo_id}`).classed('hidden', true);
                labelContainer.selectAll(`.lbl_${d.properties.geo_id}`).classed('hidden', true);
                // setTimeout(function() {
                //     d3.select("#tooltip").classed("hidden", true);
                // }, 3000);
            });

        function ticked() {
            labels
                .style("left", function(d) { return d.x + "px"; })
                .style("top", function(d) { return d.y + "px"; });
        }


        var labels = labelContainer.selectAll(".label")
            .data(data.features)
            .enter().append("div")
            .attr("class", function(d){return `label hidden lbl_${d.properties.geo_id}`})
            .style("position", "absolute")
            .html(function(d) { 
                var title = d.properties.name.replace(", HI - ", " ");
                var details = Math.round(d.properties.density) + " p/kmÂ²";
                var pop = d.properties.population;
                return `${title}<br />${details}<br />${pop}`;
            });        

        var simulation = d3.forceSimulation(data.features)
            .force("x", d3.forceX(function(d) { return path.centroid(d)[0]; }).strength(8))
            .force("y", d3.forceY(function(d) { return path.centroid(d)[1]; }).strength(8))
            .force("collision", d3.forceCollide().radius(function(d) { 
                return labels.nodes()[data.features.indexOf(d)].offsetWidth / 2 + 1;
            }))
            .force("centerRepulsion", d3.forceManyBody().strength(function(d) {
                // Calculate the distance from the label to the center
                var dx = path.centroid(d)[0] - centerX;
                var dy = path.centroid(d)[1] - centerY;
                var distance = Math.sqrt(dx*dx + dy*dy);

                // Set a negative strength for repulsion, you can adjust the multiplier
                // for more or less repulsion as needed
                return -40 * distance;
            }))
            .on("tick", ticked)
            .on("end", drawLines)
            .alphaDecay(0.05);


        var labelRects = svg.selectAll(".label-rect")
            .data(data.features)
            .enter().append("rect")
            .attr("class", function(d){return "label-rect"})
            .attr("x", function(d) { return d.x - this.getBBox().width / 2; })
            .attr("y", function(d) { return d.y - this.getBBox().height / 2; })
            .attr("width", function(d) { return this.getBBox().width; })
            .attr("height", function(d) { return this.getBBox().height; });

        function drawLines() {
            svg.selectAll(".centroid-line")
                .data(data.features)
                .enter().append("line")
                .attr("class", function(d){return `centroid-line hidden lbl_${d.properties.geo_id}`})
                .attr("x1", function(d) { return path.centroid(d)[0]; })
                .attr("y1", function(d) { return path.centroid(d)[1]; })
                .attr("x2", function(d) { return d.x; })
                .attr("y2", function(d) { return d.y; })
        }

        });
</script>

</body>
</html>
